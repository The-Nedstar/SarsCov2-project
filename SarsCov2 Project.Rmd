---
title: "Sars Cov2 Project"
output: html_document
date: "2025-03-17"
bibliography: references.bib
nocite: "@whitlock2020analysis, @nichols, @wickham2023r"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r loading libraries and functions}
rm(list = ls())

## loading libraries
library(tidyverse)
library(here)
library(RColorBrewer)
library(gridExtra)
library(MCMCpack)
library(EpiEstim)
library(incidence)

## installing self made functions
source(here("Data", "Functions.R"))
```

# Question 1

## 1.

```{r loading data}
GenPerWeek <- read.csv(here("Data", "Genomes_per_week_in_England.csv"))
```

## 2.

```{r Changing non major lineages to "Other"}
## defining major lineages
MajLin <- c("B.1.1.7", "B.1.617.2", "BA.1", "BA.2", "BA.2.75", 
            "BA.4", "BA.5", "BA.5.3", "XBB", "Other")

## altering the values in the column to Other if not major
GenPerWeek <- GenPerWeek %>% 
  mutate(lineage = case_when(
    lineage %in% MajLin ~ lineage, TRUE ~ "Other"), # changing values not in major lineages to "Other"
    lineage = factor(lineage, levels = MajLin),date = as.Date(date)) %>%  # converting the lineage into categorical factors and the date into a date
  group_by(date, lineage) %>% # grouping values from the same lineage and week
  summarise(count = sum(count)) # adding them all together into one value
```

## 3.

```{r visualation in a stacked area plot}
## using a self made function to create the stacked area plot
stacked_area_plot(GenPerWeek, GenPerWeek$date, "time", GenPerWeek$count,
                  "total counts", GenPerWeek$lineage, 
                  "total counts of Covid lineages per week in England",
                  "TotalCountsAP.png")
```

![Fig 1:](Figures/TotalCountsAP.png)

```{r Proportion graph}
## calculation proportion values
# creating a new dataframe which contains the total counts for each week
TotCount <- aggregate(GenPerWeek$count, by = list(date = GenPerWeek$date), 
                      FUN = sum)
# changing the column names so it can be added back
colnames(TotCount) <- c("date", "total_count")
# adding the total counts to each row from a set week
GenPerWeek <- merge(GenPerWeek, TotCount, by = "date")
# creating a new column with the calculated proportion
GenPerWeek$proportion <- GenPerWeek$count / GenPerWeek$total_count

## using a self made function to create the stacked area plot
stacked_area_plot(GenPerWeek, GenPerWeek$date, "time", GenPerWeek$proportion,
                  "proportion", GenPerWeek$lineage, 
                  "Proportion of Covid lineages per week in England", 
                  "ProportionAP.png")
```

![Fig 2:](Figures/ProportionAP.png)

# Question 2

## 1.

```{r Loading Data}
## downloading data
ONSData <- read.csv("https://raw.githubusercontent.com/mg878/variant_fitness_practical/main/lineage_data.csv")
ONSData$collection_date <- as.Date(ONSData$collection_date)

## Data wrangling
# combining values from the same lineage together
ONSSum <- aggregate(ONSData$major_lineage,
                    by = list(collection_date = ONSData$collection_date, 
                              major_lineage = ONSData$major_lineage), FUN = length)
# changing collumn names
colnames(ONSSum) <- c("collection_date", "major_lineage", "lineage_count")

```

```{r calculations}
## totals
# combining all values with the same collection date
total_counts <- aggregate(ONSSum$lineage_count, 
                          by = list(collection_date = ONSSum$collection_date), 
                          FUN = sum)
# change names to fit the original dataframe
colnames(total_counts) <- c("collection_date", "total_count")
# add to the original dataframe
ONSSum <- merge(ONSSum, total_counts, by = "collection_date")

## calculate frequencies
ONSSum$lineage_frequency <- ONSSum$lineage_count / ONSSum$total_count

## grouping data into 10s
# creating a column with dates grouped into 10s 
ONSSum$collection_date_bin <- as.Date(floor(as.numeric(
  as.Date(ONSSum$collection_date)) / 10) * 10, 
  origin = "1970-01-01")
# creating a new dataframe with each 10 day period summed
ONSSumBin <- aggregate(lineage_count ~ collection_date_bin + major_lineage, 
                       data = ONSSum, FUN = sum)
# Calculate total counts within each bin
total_counts <- aggregate(lineage_count ~ collection_date_bin,
                          data = ONSSumBin,FUN = sum)
#change to fit with original dataframe
colnames(total_counts) <- c("collection_date_bin", "total_count") 
# add back to dataset
ONSSumBin <- merge(ONSSumBin, total_counts, by = "collection_date_bin")
# Recalculate frequencies
ONSSumBin$lineage_frequency <- ONSSumBin$lineage_count / ONSSumBin$total_count
```

```{r}
## Data wrangling
# creating dataframe with only BA.2 and only the relevant columns
ONSBA2 <- subset(ONSSumBin, major_lineage == "BA.2", 
                 select = c(collection_date_bin, lineage_count))
# renaming columns for easy combination later
colnames(ONSBA2) <- c("date", "count")
# creating a new dataframe with values normalised to match the COG data
ONSBA2c <- ONSBA2 %>% mutate(count = count * 6.6667)
# adding a factor column to identify these values as ONS-CIS derived
ONSBA2c$Data <- as.factor("ONS-CIS")
  
# creating dataframe with only BA.2 and only the relevant columns  
COGBA2 <- subset(GenPerWeek, lineage == "BA.2",
                 select = c("date", "count"))
# creating a new dataframe with the same time period as the ONS-CIS data
COGBA2c <- subset(COGBA2, date > as.Date("2021-12-18"))
# adding a factor column to identify these values as COG-UK derived
COGBA2c$Data <- as.factor("COG-UK")

# creating a combined dataset
Both <- bind_rows(ONSBA2c, COGBA2c)

## Plotting
# creating a plot for the ONS-CIS data using a self made function
ONSPlot <- single_lineage_plot(ONSBA2, ONSBA2$date, "time", ONSBA2$count, "count", 
                               "c) Lineage tragectory for BA.2 (ONS-CIS)")
# creating a plot for the COG-UK data using a self made function
COGPlot <- single_lineage_plot(COGBA2, COGBA2$date, "time", COGBA2$count, "count", 
                               "b) Full Lineage tragectory for BA.2 (COG-UK)")
# creating a plot for the cropped COG-UK data using a self made function
COGPlot2 <- single_lineage_plot(COGBA2c, COGBA2c$date, "time", COGBA2c$count,
                               "count", 
                               "a) Cropped Lineage tragectory for BA.2 (COG-UK)")
# creating a plot with both datasets shown together
BothPlot <- multi_lineage_plot(Both, Both$date, "time",
                                       Both$count, "normalised Count",
                                       Both$Data, "Dataset", "d) Combined plot")
## combinging and saving plot
# defining saving parameters
grid_plot("BA2LinPlot.png", COGPlot2, COGPlot, ONSPlot, BothPlot)
```

![Fig 3:](Figures/BA2LinPlot.png)

## 2.

Both datasets show very similar trajectories. When the count is increasing they are almost identical, starting at about the same time and growing at similar rates. They both peak at about the same time as well. However, the decrease in count after the peak is different for the ONS-CIS data taking substantially longer and having a more gradual curvature compared to the COG-UK data which has a sudden and more linear drop off.

The most likely cause for this discrepancy is the difference in sampling techniques. COG-UK data was taken from PCR testing, wherase ONS-CIS used random samples from the population. Many people would test positive for the strain long after it was causing symptoms. On top of this, people were likely to get tested early on into their infection, with a long period afterwards in which it could still be tested. Therefore, random testing of individuals is likely to pick up their infection later into it's cycle and lead to the delayed drop that we see.

# Question 3

```{r Data wrangling}
COGDeltaM <-  filter(GenPerWeek, lineage == "B.1.617.2",
                                date >= as.Date("2021-03-27") & 
                                  date <= as.Date("2021-10-02"))
COGBA1M <- filter(GenPerWeek, lineage == "BA.1",
                                date >= as.Date("2021-11-20") & 
                                  date <= as.Date("2022-01-15"))
COGBA2M <- filter(GenPerWeek, lineage == "BA.2",
                                date >= as.Date("2021-12-25") & 
                                  date <= as.Date("2022-03-26"))
```

```{r running models}
COGDeltaMFit <- nls(proportion ~ logistic_growth(as.numeric(date - min(date)),
                                                 s, f0), data = COGDeltaM,
                    start = list(s = 0.2, f0 = min(COGDeltaM$proportion)))
COGDeltaMDates <- seq(min(COGDeltaM$date), max(COGDeltaM$date), by = "1 day")

# Calculate predicted frequencies for smooth (continuous) dates 
COGDeltaMPred <- data.frame(date = COGDeltaMDates,
  predicted_frequency = logistic_growth(as.numeric(COGDeltaMDates - 
                                                     min(COGDeltaM$date)),
                                        coef(COGDeltaMFit)["s"], 
                                        coef(COGDeltaMFit)["f0"]))
COGDeltaMPred$Data <- as.factor("Delta")

COGBA1MFit <- nls(proportion ~ logistic_growth(as.numeric(date - min(date)),
                                                 s, f0), data = COGBA1M,
                    start = list(s = 0.2, f0 = min(COGBA1M$proportion)))
COGBA1MDates <- seq(min(COGBA1M$date), max(COGBA1M$date), by = "1 day")

# Calculate predicted frequencies for smooth (continuous) dates 
COGBA1MPred <- data.frame(date = COGBA1MDates,
  predicted_frequency = logistic_growth(as.numeric(COGBA1MDates - 
                                                     min(COGBA1M$date)),
                                        coef(COGBA1MFit)["s"], 
                                        coef(COGBA1MFit)["f0"]))
COGBA1MPred$Data <- as.factor("BA.1")
COGBA1MPred1 <- COGBA1MPred
COGBA1MPred1$date <- as.Date(as.Date(COGBA1MPred1$date)-238)

COGBA2MFit <- nls(proportion ~ logistic_growth(as.numeric(date - min(date)),
                                                 s, f0), data = COGBA2M,
                    start = list(s = 0.2, f0 = min(COGBA2M$proportion)))
COGBA2MDates <- seq(min(COGBA2M$date), max(COGBA2M$date), by = "1 day")

# Calculate predicted frequencies for smooth (continuous) dates 
COGBA2MPred <- data.frame(date = COGBA2MDates,
  predicted_frequency = logistic_growth(as.numeric(COGBA2MDates - 
                                                     min(COGBA2M$date)),
                                        coef(COGBA2MFit)["s"], 
                                        coef(COGBA2MFit)["f0"]))
COGBA2MPred$Data <- as.factor("BA.2")
COGBA2MPred1 <- COGBA2MPred
COGBA2MPred1$date <- as.Date(as.Date(COGBA2MPred1$date)-273)
COGCombMPred <- bind_rows(COGDeltaMPred,COGBA1MPred1,COGBA2MPred1)
```

```{r plotting}
COGDeltaMPredPlot <- single_lineage_plot(COGDeltaMPred, COGDeltaMPred$date,
                                         "time",
                                         COGDeltaMPred$predicted_frequency,
                                         "predicted frequency", 
                                         paste("a) predicted Delta frequency, s =",
                                               round(coef(COGDeltaMFit)["s"],4)))

COGBA1MPredPlot <- single_lineage_plot(COGBA1MPred, COGBA1MPred$date,
                                         "time",
                                         COGBA1MPred$predicted_frequency,
                                         "predicted frequency", 
                                         paste("b) predicted BA.1 frequency, s =",
                                               round(coef(COGBA1MFit)["s"],4)))
COGBA2MPredPlot <- single_lineage_plot(COGBA2MPred, COGBA2MPred$date,
                                         "time",
                                         COGBA2MPred$predicted_frequency,
                                         "predicted frequency", 
                                         paste("c) predicted BA.1 frequency, s =",
                                               round(coef(COGBA2MFit)["s"],4)))

# creating a plot with both datasets shown together
COGCombMPredPlot <- multi_lineage_plot(COGCombMPred, COGCombMPred$date, "time",
                                       COGCombMPred$predicted_frequency, "predicted frequency",
                                       COGCombMPred$Data, "lineage", "d) Combined plot")
## combinging and saving plot
# defining saving parameters
grid_plot("COGCombPredPlot.png", COGDeltaMPredPlot, COGBA1MPredPlot, COGBA2MPredPlot, 
         COGCombMPredPlot)

```

![](Figures/COGCombPredPlot.png)
